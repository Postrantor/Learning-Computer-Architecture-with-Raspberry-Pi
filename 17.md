Chapter 11

# Audio

**SOUND CAPABILITY ON** computers is certainly a significant matter. An old adage in the film and video industry states, “Sound is 70 percent of your production”. Sound accentuates the visual, sets moods, increases excitement, inspires the user and more. Computer games are one great example that demonstrates the importance of sound.

In short, this chapter is an exploration of sound on computers in general and specifically how the architecture of the Raspberry Pi supports music and all sorts of other sound manipulations. We discuss analog versus digital audio, sound over High Definition Multimedia Interface (HDMI), 1-bit digital analog conversion (DAC), both signal and sound processing, and Inter-IC Sound (I<sup>2</sup>S, a communications protocol for carrying digital audio signals).

We also cover the Raspberry Pi’s onboard sound, both the input and output features. We begin with the basics of sound on computers and a little history.

## Can You Hear Me Now?

Right after World War II ended, the first computers were silent—except, of course, for the grinding and clacking of gears in the mechanical computers, the buzzing of power supplies and the _plink_ of vacuum tubes burning out in electronic mainframes. Then there was also the often-colourful language of operators when these monsters crashed due to faulty programs and the lack of operating systems to prevent or recover from the software mishap, necessitating a lengthy reboot.

The “language” we’re referring to is not COBOL or FORTRAN—or, to be more modern, Python or JavaScript. We’re talking about those nifty words learned by the soldiers, sailors, and airmen in combat during the war and generously passed to their fellow operators after they came into the growing data processing field.

Notice that when you read the preceding two paragraphs you hear sounds, even if they’re only in your head. Sound sets the stage and creates atmosphere. Sound is important. Think of this classic movie moment, the computer HAL 9000 singing “Daisy Bell” in the film _2001: A Space Odyssey_. Inspired by the IBM 7094 (from 1961), Hal provided an iconic moment in cinema and computer-generated sound/voice history. Although special effects were used at the time, computer sound capabilities quickly have become reality.

### MIDI

The true dawn of sound on computers, at least so far as widespread user interest is concerned, came with the advent of the personal computer. For the purposes of this discussion we consider that to have happened in 1980, when the Commodore 64, Radio Shack’s TRS-80 and the Apple II were popular. Then in 1981, IBM’s first IBM PC came on the market and more people started using personal computers for pleasure, such as playing games, as well as doing real work. Consequently, the sounds made by personal computers started to matter more and more, especially as people interested in music were figuring out ways for computers to assist them.

In 1981, the Musical Instrument Digital Interface (MIDI) hit the music industry. It caused a lot of excitement among both professional and amateur musicians. Now you could turn music into _data_ right on your personal computer. You could load it into a device called a sequencer, edit it, save it and play it back later. Cool!

Of course, it occurred to many people that _their_ personal computers would be ideal for this purpose. Soon MIDI add-on cards and sequencing software hit the market. People could add a MIDI player to their computers and download all sorts of MIDI music from bulletin boards (which were precursors to the Internet).

### Sound Cards

Of course, it is rather hard to enjoy music if you cannot hear it. Yes, many of the early computers, such as the IBM PC, came with tiny built-in speakers. These were good for little more than the occasional diagnostic beep or other system sound. In fact, that was their design purpose. They provided a limited audio frequency range and very low power. It was useless to hope for decent music reproduction from them.

For quite some time, the best way to achieve good sound in a personal computer was with an add-on card. It took about six years for sound cards to become common built-in features in computers.

Beginning around 1988, sound cards became common and several good choices existed, which meant digital audio moved from being a possibility to a necessity for many computer owners. These cards included capability for sound amplification and they supported external speakers, which remains the norm for personal computers today.

Most modern personal computers come boxed with decent sound cards, speakers, network adapters and other accessories for which you once had to buy additional cards. However, for the very best in sound, great alternatives exist, from speakers to a separate subwoofer bass box that can shake your whole house.

Computers with add-on sound cards had the capability to digitally record output from the speakers to the microphone input. A number of truly professional sound cards are available for turning your computer into a studio-level sound editor and mixer.

Today, computer sound rocks. Now you need to know how it works.

## Analog vs. Digital

People began using and recording sound in the nineteenth century—think of Alexander Graham Bell’s telephone (see Figure 11-1), Thomas Edison’s phonograph, and so on. This type of producing sound and the recording of it used a _transducer_ (a microphone is one of those) to convert variations in air pressure to an electrical waveform that changed in frequency and amplitude to match the actual sounds. When played back on a speaker (which is like a reverse transducer), people heard a close approximation of the recorded sounds. This type of recording is known as _analog._

![[FIGURE 11-1:](#14_9781119183938-ch11.xhtml#rc11-fig-0001) An 1876 photo of Alexander Graham Bell’s famous first call on the first telephone, “Come here, Mr. Watson, I want to see you,” was all analog sound.](./media/images/9781119183938-fg1101.png)

Over the next hundred years, analog sound recording techniques got very good indeed. Tapes and records played through high-end stereo equipment certainly approached the quality of “being there”. So, you might now ask, “If analog is so good, why change?”

The answer is simple: only the first generation (the original) recording is good. If you copy, say, the master tape from a recording studio onto another tape, it creates a little noise, and all those squiggly audio waves become slightly distorted. Copying the copy introduces more noise, and so on. Static, hisses, whistles. Besides, because computers are digital, they can’t manipulate recorded sound.

_Digital audio_ solves the noise problem and makes for easy editing in many ways. When sound comes into a digital recorder—via a microphone or from a recorded analog tape or some other medium—the recorder changes the waveforms into binary 1s and 0s that the computer can understand. In other words, the sounds become _data_ and can be formatted and saved as an audio file such as `.wav`</code> or `.mp3`.

A digital audio file can be copied hundreds, thousands, millions of times and remain exactly the same quality as the first-generation file. No noise is introduced. In addition, the file is now in digital format and thus available for editing, cutting, enhancing and mixing in all sorts of ways.

It was once true that analog techniques provided all electronic sound, the sound itself being a recording of what humans could actually hear. That’s not the case anymore. Software can create music and other sounds from scratch, all digitally. Hundreds of music creation programs, which are available on the Internet, aid in this creation of virtual music, sound effects and even synthesis of artificial “human” speech.

To sum up, in a comparison of analog and digital audio, digital wins for three major reasons:

- Sounds and/or music become computer data, which is easy to manipulate. - No noise is introduced, regardless of how many generations of copies you make. - Software can create digital music and sound with any analog input.

## Sound and Signal Processing

Processing audio refers to several things, most of which concern deliberately modifying a recorded or created digital audio file. This section gives a general overview of audio processing. An explanation of the hardware specifics and computer architecture that make sound, input and output possible follow later in this chapter. The chapter concludes with information about how to actually edit sound using the Raspberry Pi and its onboard sound hardware.

With the advent of digital audio, manipulating audio with computers rapidly replaced the old methods, and digital audio now dominates in the music industry, broadcasting, home recording and so forth. Podcasts (recorded segments like radio programs but intended to be played online) proliferate on the Internet, and music lovers download millions upon millions of music files daily.

Computerised audio manipulation can take several forms:

- Editing the file to delete or add sounds, adjust the volume, and so on - Recording the audio with special effects (reverb, for example) or adding effects during editing. - Compressing the file to make high and low amplitudes even out and improve sound - Encoding or decoding information from audio for the purpose of computer operation, data collection or various modes of digital communication

### Editing

In the days of analog-only sound, editing was a pain. To remove a small bit of annoying noise in a recording, one had to cue the tape, guess where the offending sound lay, use a razor blade or scissors to cut out the section and then glue the tape back together. (Film editing used the same process.) Precise? Definitely not.

To edit digital audio today, you look at the waveform or waveforms, use a mouse pointer to highlight the part that needs to go and press the Delete button. When you play the file, you cannot tell where the edits took place.

Editing enables you to adjust volume, reduce noise—including wind pops in microphones that happen while recording outdoors, or someone’s cough during a concert—and do many other things such as adding various enhancing effects, which is covered in the next section.

Editing includes _mixing_ (combining audio waves) of many _tracks_. During recording of an orchestra, for example, there might be 20 or more microphones spread around to record different tracks. By combining or emphasising various tracks, the person editing the final release of this recording can work all sorts of magic to get a more pleasing and inspiring result.

### Compression

_Compression_ of an audio waveform allows better quality audio on transmission media than other degrade reproduction. Recordings of old time AM broadcast and movies from the 1930s and 1940s provide a prime example. Voices especially sound tinny, less full and rich than they do in modern broadcast and movie audio. In radio audio, this tininess was emphasized by audio-limiting circuits designed to protect transmitters from over-modulation damage as well as preventing distortion. In other words, an announcer shouting on air could blow an expensive transmitter and shut down the station.

Pioneering effects, such as the CBS radio network’s Audimax system in the 1960s, changed that by making earlier attempts at compression practical. Compression techniques allow reproduction of voice and music more accurately and distortion free.

Two types of compression are popular and available in software (such as Audacity) for the Raspberry Pi:

- **Audio compression:** Reduces the amount of data in an audio waveform to effect accurate reproduction via CD, MP3, Internet radio and so forth with little or no loss of quality - **Dynamic range compression:** Reduces the difference between loud and quiet, again resulting in accurate reproduction

### Recording with Effects

Features that enable you to modify all or parts of sound files are called _effects._ Effects add ambience, excitement, fullness and other changes to sounds that do not exist in the original recording. Effects can turn drab reality into a magical virtual soundscape. You can even use more than one effect on a sound. Some standard examples of effects include:

- **Echo:** Gives the effect of sound echoing off the walls of a large hall or cavern - **Chorus:** Adds a very slight delay to make one recorded voice sound like more than one person or make a group of recorded voices sound like many more - **Pitch shift:** Moves the pitch of music or other sounds up or down; for example, you could copy a track, move the pitch of the copy up or down an octave and mix it with the original track for an interesting effect. You can also change the pitch of an actor’s voice to use for a cartoon character. Pitch shift can also be used to change the pitch of an out-of-tune singer so that their voice is in tune.

  ---

[!NOTE]

>

Some karaoke machines use pitch shift in real time to assist singers, making them sound better than they actually are. Called _autotune_, this technique is common in pop culture these days and is even used by professional singers.

- **Robotic voice effects:** Turns the human voice into a mechanical synthesised version. Add a pitch shift effect for a scary result - **Time stretching:** Increases or decreases speed of an audio signal without affecting its pitch

Hundreds more effects exist, either in audio editing software or available to be downloaded and added as needed. Figure 11-2 shows an example of Adobe Audition, which is part of the Creative Cloud suite and offers extensive sound editing capabilities.

![[FIGURE 11-2:](#14_9781119183938-ch11.xhtml#rc11-fig-0002) Adobe Audition professional sound editing program showing some of the many effects available](./media/images/9781119183938-fg1102.png)

### Encoding and Decoding Information for Communication

Voice recognition is an example of encoding information for controlling software and computers. For example, when you say “Stop” and a program on a computer ends, it’s because your word is compared against an encoded version of the word _stop_ and recognized, and the command is initiated. (Naturally the computer must have a microphone attached and software for identifying and comparing words to their encoded versions.)

Sensors, industrial instruments, satellites and thousands of other devices on the Internet of Things use variously modulated audio signals to accept and return information. These audio signals are not necessarily words but various commands and other data encoded into audio waveforms. _Decoding_ is the process by which the information is extracted and acted on.

Broadcast radio and TV stations add modulated sound waves to their radio frequency carriers to send out voice and music. The radio waveform is encoded with the program material. Your receiver decodes it and converts the voice and music to sound for your enjoyment.

Here’s another example: if you’ve ever seen an amateur radio operator sending Morse code, that’s sound manipulation, resulting in _dits_ and _dahs_ reproduced after being sent through the air to another radio ham’s receiver and a message being passed hundreds or thousands of miles. The same is true of more sophisticated methods of communications like radioteletype (RTTY) and technically cutting-edge advances like JT65 or JT9 (low signal modes allowing consistent communications between continents with only a few watts), as shown in Figure 11-3.

![[FIGURE 11-3:](#14_9781119183938-ch11.xhtml#rc11-fig-0003) A radio ham in North Carolina contacts another in Hungary using a computer to convert typed messages into digital waveforms which modulate a radio signal received and decoded by the computer of the ham in Europe.](./media/images/9781119183938-fg1103.png)

The multitude of sound and signal processing applications continues to grow rapidly.

## 1-Bit DAC

DAC stands for digital-to-analog converter and ADC stands for analog-to-digital converter. DAC is also known as a bitstream converter.

Earlier in the chapter we discussed the advantages of digital audio over analog, but this does not mean digital audio has totally replaced analog audio. Why? After all, you can plug headphones into the 3.5mm audio jack on the Raspberry Pi board and hear music. Headphones are transducers that convert recorded analog waveforms to sound waves (which are vibrations in the air) and flings them against your eardrums. To make this happen, some kind of digital-to-analog conversion has to happen on the Raspberry Pi board. If you want to use both video and audio via the audio jack on a Raspberry Pi 2 or B+, you need a connector like the one shown in Figure 11-4.

---

> [!NOTE]

The type of connector shown in [Figure 11-4](#14_9781119183938-ch11.xhtml#c11-fig-0004) includes provision for video as well as audio, whereas the audio jack on the older Model B is a standard stereo configuration with the composite video jack separate.

Prior to Raspberry Pi 2, the stereo jack was not the “3 pole” variety, and it was used only for audio. But there’s good news: the plug in [Figure 11-4](#14_9781119183938-ch11.xhtml#c11-fig-0004) is 4-pole (TRRS or Tip, Ring, Ring, Sleeve), but the conventional 3-pole stereo plug (such as the one on headphones) still works! Only when you’re using video does this plug require a 4-pole connector.

![[FIGURE 11-4:](#14_9781119183938-ch11.xhtml#rc11-fig-0004) Connections on a 3.5mm plug to match the Raspberry Pi](./media/images/9781119183938-fg1104.png)

Bear in mind that a computer costing around £30 retail might not have the highest possible quality of audio. The quality isn’t terrible, though, and the HDMI connector supplies very acceptable sound. The audio from the 3.5mm stereo audio jack, however, does not have as much quality. What is the difference between the two? The 3.5mm jack outputs analog audio and the HDMI jack outputs digital audio.

The Raspberry Pi’s onboard DAC conversion is generated by the Pulse Width Modulation (PWM) module and is 1-bit. This is not bad. Many CD players, boom boxes, and other sound-producing consumer electronic devices use 1-bit DACs (or the equivalent) with great results. The 1-bit DAC samples audio at several times its actual rate, converting with quality similar to 16 to 20 bits; in the Raspberry P, however, it’s stated as being equivalent to only 11 bit. 1-bit DAC is also cheap, which is something important to manufacturers of low-cost units.

An ADC measures analog audio amplitudes many times each second, storing those as numbers in a file. The most common format used for this in computers is pulse code modulation (PCM). The digital-to-analog conversion DAC, such as the PWM emulation of 1-bit DAC on the Raspberry Pi board, samples a PCM audio file and reconstructs the analog waveform according to the numeric data in the PCM file.

To simplify, a soundwave varies continuously in amplitude over time. The ADC rapidly measures the wave many times a second, recording the amplitude of the wave each time. These points then are encoded into a digital pulse width waveform. When that PWM waveform is decoded, the original analog waveform is reconstruction and can drive a speaker or headphone thus playing the original content.

The problem here is that you may have beautiful music produced in a studio and turned into a 24-bit audio file. Although the 1-bit DAC reads the file okay, it’s reconstructing the analog waveform of the music based on its overrate sampling technique which is 11-bit (in the Raspberry Pi’s case) to 20-bit, instead of the file’s native 24-bit quality. Small distortions due to this faster sampling might also creep in.

---

> [!NOTE]

The term _overrate_ in the preceding paragraph is significant for bandwidth-limited waveforms such as those produced by the type of DAC described earlier. There is a term in signal processing called the _Nyquist rate_, which is twice the highest frequency in a waveform. Theoretically, at least, such a waveform can be more accurately decoded if sampled above the Nyquist rate, thus reducing noise and distortion. This over-rate technique is how the equivalent 11-bit rate is achieved from a 1-bit DAC encoded file.

When using the Raspberry Pi as a media centre driving high-end amplifiers and speaker systems, you want the best sound possible. The Raspberry Pi can do it, but you need to hang a higher quality DAC from it, which is a cheap and easy solution. With a 24-bit DAC, you will get more clarity and depth of sound. The difference is subtle, but it is definitely there.

So, how does the Raspberry Pi communicate with this better DAC? It happens via a sound transport protocol referred to as I<sup>2</sup>S.

## I<sup>2</sup>S

_I<sup>2</sup>S_—which is short for Inter-IC Sound, Interchip Sound or IIS—is a type of serial bus interface standard that connects digital audio devices to one another. As an example, I<sup>2</sup>S connects the Raspberry Pi to an external DAC.

But wait. You may have noticed we have nothing labelled “I<sup>2</sup>S Connector” on the Raspberry Pi board. We could use one of the USB ports for outputting PCM audio to a DAC, but that can introduce distortion. The best solution is to use the general purpose input output (GPIO) pins on the Raspberry Pi board. Also, it’s best to use the shortest path possible. Consequently, external DAC boards for the Raspberry Pi plug directly into the GPIO pins.

You might want to check out the following list of DAC boards, all of which cost less than £25:

- **SainSmart HIFI DAC Audio Sound Card Module for Raspberry Pi 2** ([`www.sainsmart.com/sainsmart-hifi-dac-audio-sound-card-module-i2s-interface-for-raspberry-pi-2-b.html`](http://www.sainsmart.com/sainsmart-hifi-dac-audio-sound-card-module-i2s-interface-for-raspberry-pi-2-b.html)): Plugs directly to the Raspberry Pi board. - **HiFiBerry DAC+** ([`www.hifiberry.com/dac/`](http://www.hifiberry.com/dac/)): Plugs into A, B, B+, and 2, but it may not work with some older As and Bs. - **Eleduino HIFI DAC Audio Sound Card Module** ([`http://www.eleduino.com/HIFI-DAC-Audio-Sound-Card-Module-I2S-interface-for-Raspberry-pi-B-Raspberry-Pi-2-Model-B-p10546.html`](http://www.eleduino.com/HIFI-DAC-Audio-Sound-Card-Module-I2S-interface-for-Raspberry-pi-B-Raspberry-Pi-2-Model-B-p10546.html)) - **Arducam HIFI DAC Audio Sound Card Module** ([`http://www.amazon.com/Arducam-Audio-Module-Interface-Raspberry/dp/B013JZI3DS`](http://www.amazon.com/Arducam-Audio-Module-Interface-Raspberry/dp/B013JZI3DS))

---

> [!NOTE]

You can find other options for DAC boards by searching for “Raspberry Pi DAC”.

## Raspberry Pi Sound Input/Output

The Raspberry Pi supplies two types of connector for getting sound into and out of it: the audio output jack and the HDMI jack.

### Audio Output Jack

The Raspberry Pi board provides a standard 3.5mm audio stereo jack. Here you can plug in headphones, powered speakers or anything else that takes and plays audio input and matches the connections of the jack.

A limitation of this output is the quality of sound. The audio out from this connector, as specs state, is 11-bit. (For truly good sounding music you want 16-bit or 24-bit.)

No worries, though: like other Raspberry Pi limitations, solutions abound. For example, you can add a generic USB/audio adapter. One of these adapters puts out better sound and allows for microphone _input_ as well. This lets you use the Raspberry Pi as a voice or music recorder, or teach it to work via voice commands, and so forth. Alternatively, as mentioned earlier in the chapter, an external DAC board is the yellow brick road to high-end quality sound.

### HDMI

HDMI was developed in the early 2000s as a method of transferring high-quality video and audio to playback devices. A number of versions exist, but they all use the same cable and connectors. The Raspberry Pi includes an HDMI connector on its board.

---

> [!NOTE]

HDMI is a proprietary interface owned by a consortium of large flat-screen TV manufacturers. The development of HDMI technology paralleled and contributed to the rise of these big entertainment devices. Big screens require better picture quality, and home theatre sound systems require better audio.

There’s nothing as fine as a nice big display that shows the colourful graphic user interface (GUI) of the Raspberry Pi and enables you to watch videos, play games and do all the stuff you expect a computer to do. The best solution involves HDMI, and here are two of the advantages of using HDMI output:

- HDMI allows the transfer of video and audio from an HDMI-compliant display controller (think Raspberry Pi here) to compatible computer monitors, projectors, digital TVs or digital audio devices. - HDMI’s higher quality provides a marked advantage over composite video (such as what comes out of the yellow or sometimes black connector on the Raspberry Pi board). This also provides a display that’s much easier on the eyes and provides higher resolution instead of composite video’s noisy and sometimes distorted video and/or audio.

---

> [!WARING]

It is important to know that HDMI-to-HDMI connections include _both_ video and audio. For connections that convert HDMI to DVI (Digital Video Interface) or VGA (Video Graphics Array), only video goes through the connection. Your options for audio include a separate audio cable from the audio out port of the Raspberry Pi. Alternatively, some adapters recommended earlier in this chapter have audio ports. You still need to run an audio cable from the converter’s connector to the audio input on the monitor or to separate speakers.

Remember, audio coming from the HDMI output of the Raspberry Pi is better quality than from the 3.5mm audio output jack. Although it might seem like a good idea to plug in nice computer speakers that include a built-in amplifier, or any other powered speaker, the best method employs the Raspberry Pi’s onboard I<sup>2</sup>S to a separate DAC.

## Sound on the Raspberry Pi

Do not mistake our suggestion of using an external DAC for a complaint that the Raspberry Pi has bad sound. It does not. It has _great_ sound features. In this section, we look at the Raspberry Pi’s onboard sound hardware and then see how this fantastic little computer enables us to manipulate sound in all sorts of good ways.

### Raspberry Pi Sound on Board

As of the Raspberry Pi 2, all of the Raspberry Pi 2’s magic occurs in the Broadcom BM2535 system-on-a-chip (SoC). Among other things, this chip provides the following three things that provide the Raspberry Pi 2’s audio features:

- DAC conversion providing left and right stereo analog audio for the 3.5mm jack - HDMI digital audio - Support of I<sup>2</sup>S audio transport

Now that you know where the magic happens, it’s time to do something practical, such as editing audio.

### Manipulating Sound on the Raspberry Pi

As mentioned in [Chapter 8](#11_9781119183938-ch08.xhtml), Raspbian (a version of Debian Linux optimised for the Raspberry Pi) is a good starting point for installing as an operating system. The audio editing techniques in this section work in most Linux distros on the Raspberry Pi, but we have used Raspbian for our examples.

#### Selecting Audio Devices

Like many devices with powerful modern operating systems, the Raspberry Pi recognises several methods of achieving most goals. For example, there’s more than one way to select the audio device.

The Raspberry Pi comes with two methods of audio playback. The first is analog stereo with digital files converted to work with headphones or speakers. The second is HDMI, which features higher-quality digital sound. A 4-pole connector is supplied for analog audio output and there’s also an HDMI connector for cabling to TVs, stereo systems and other HDMI-enabled devices.

The default output method is to use the 4-pole 3.5mm socket on the Raspberry Pi board (video output possible in addition to sound). As explained earlier in this chapter, using a standard 3-pole mini stereo plug, such as those on the end of headphones or computer speakers, works by design also, so you can use any powered computer speakers and your Raspberry Pi will sound good.

#### MAKING A PERMANENT CHANGE

Let’s say you’re using the Raspberry Pi as an entertainment centre controller hooked to a TV and/or stereo system. In that case, manually selecting HDMI after booting the Raspberry Pi would become a pain. Here’s the solution for that:

1. Open the command-line terminal (usually the little TV-like icon with a black screen). 2. Type the command `sudo raspi-config`. (The `sudo` means super user do, giving you permission to change configuration—in this case the way the board boots up.) 3. After the Raspberry Pi Software Configuration Tool screen appears (see Figure 11-5), use the down arrow key and select 9 Advanced Options. Press Enter. 4. Select A9 Audio. 5. On the Choose the Audio Output screen, select 2 Force HDMI. 6. Click OK and then click Finish. 7. Reboot the Raspberry Pi.

![[FIGURE 11-5:](#14_9781119183938-ch11.xhtml#rc11-fig-0005) Raspberry Pi Software Configuration Tool](./media/images/9781119183938-fg1105.png)

From now on, the Raspberry Pi boots up with the HDMI as the default audio output device.

#### SELECTING OUTPUT MANUALLY

Manual selection of how you want sound output from a Raspberry Pi is easy. To begin simply, we can use the omxplayer utility, which is included in Raspbian. This player not only plays standard audio digital file formats such as `.wav` and `.mp3` but it also plays video formats including `.mp4` and `.avi`.

---

> [!NOTE]

```
.mp3` is a very popular format for music, but it’s a proprietary format. To play it, you’ll need to install an encoder/decoder, such as lame. It’s free. Install it using the command



sudo apt-get install lame
```

Then omxplayer plays MP3s without further effort on your part.

The omxplayer utility has no GUI capability, so you use it in the terminal with command-line instructions. For example, you invoke omxplayer with only the name of a digital file. The command

```
omxplayer Beethoven_Ode_To_Joy.wav
```

plays the file on the default device, depending on what you’ve set in the procedure described in the preceding section.

The command

```
omxplayer -local Beethoven_Ode_To_Joy.wav
```

produces output to the 3.5mm audio connector and the command

```
omxplayer -hdmi Beethoven_Ode_To_Joy.wav
```

produces output to the HDMI connector.

The omxplayer utility contains many other options. Type its name in the terminal without parameters to get a list of these.

#### Playing Audio

A number of media players—software that plays both audio and video files—exist for the Raspberry Pi. These allow operation from the desktop in your operating system. On Raspbian, a good starting point is XiX. You can download the Linux ARM version and installation instructions at [`www.xixmusicplayer.org`](http://www.xixmusicplayer.org/).

---

> [!NOTE]

Media players should not be confused with media centre software. The latter does much more in setting up libraries and all the other functions expected of a media centre in selecting and serving entertainment. Some of the major software packages for PC and Mac also have versions that run on the Raspberry Pi, such as XBMC and Kodi.

As previously mentioned, the Raspberry Pi is certainly capable of better sound than it outputs through the 3.5mm audio connector or even the HDMI output. An inexpensive (and we mean _really inexpensive_) method involves adding a USB sound card (which is less than £7 from major online retailers). Many of these have microphone input in addition to speaker/headphone output. They are similar to the sound cards in PCs and have many of the same features, albeit in a smaller package.

These inexpensive USB sound card dongles do not require drivers. To install one, power down your Raspberry Pi, plug the dongle into a USB receptacle, and then boot up the Raspberry Pi.

You also need to switch the audio output device to the USB sound card. You can’t use the omxplayer utility for that because it currently doesn’t support USB sound. Instead, use a player called aplay. Like omxplayer, aplay is controlled through the command line using a terminal utility.

Use these steps to get aplay on Raspbian:

1. Type the following in the command line:

   `sudo apt-get install aplay
2. Get the device number for your USB sound card by typing the following on the command line:

   `aplay -l

   ---

[!NOTE]

>

The parameter in that command is not the digit one (1) but a lowercase L (l).

Look for the device number of the USB sound card and make a

> [!NOTE]
> of it. The listing on our test Raspberry Pi 2 shows several lines, but the following two show the sound devices:

`card 0: ALSA [bcm2835 ALSA], device 1: bcm2835 ALSA [bcm2835 IEC958/HDMI] ` card 1: Device [C-Media USB Audio Device], device 0: USB Audio [USB Audio]
The first, `card 0`, has 2835 in it; that’s the number of the Broadcom SoC, so we can deduce it’s the default sound output that came as part of our Raspberry Pi. The second, `card 1`, tells us it’s a C-Media USB Audio Device. 3. Get the device number, which is a little confusing because `card 1` is considered _device 0_ (because it’s the second card going to the first device—computer cards, devices, disks and so on often start numbering at 0 instead of 1). With that information, you’re ready to play music with your headphones or powered speakers plugged into the USB dongle itself. 4. Find the PCM method for your USB sound card by typing the following command (this time using an uppercase “L”):

`aplay -L

---

[!NOTE]

>

PCM is the format generated by the Raspberry Pi when converting a digital file into an analog sound output. You are going to use the `-D` option to specify a PCM method.

You see several lines of output. Look at the two listings showing the name of your USB device. In our test here using C-Media, the first line sends the digital signal without conversion. This is useful if you have a device plugged in, such as one of the DACs discussed earlier in the chapter. However, headphones, speakers and audio inputs to TVs and stereo sets are generally still analog, so you want PCM audio coming out of the USB dongle.

`hw:CARD=Device,DEV=0 ` C-Media USB Audio Device, USB Audio
`   Direct hardware device without any conversions` plughw:CARD=Device,DEV=0
`   C-Media USB Audio Device, USB Audio` Hardware device with all software conversions
For this example, `plughw:CARD=Device,DEV=0` is the information you need for the `-D` parameter required to the desired digital file (`Beethoven Ode to Joy.wav`, in this example). 5. Use the following command to play an audio file through the USB sound card:

`aplay -D plughw:CARD=Device,DEV=0 Beethoven*Ode_To_Joy.wav
Wait, we need one more item of information. It lies in the *-D\_ stuff above. As in omxplayer and many other utilities you’ll encounter, entering its name without parameters generates a list of its available commands. Doing that and looking at the -D line, we find:

-D --device=NAME select PCM by name
You’ll probably want to install a player with a nice GUI and run it from the desktop. Many players have a desktop icon you can click to switch the audio output.

#### Installing a Powerful Free Sound Editor

A good choice for an all-around useful editor that runs as it is on Raspbian (and can be installed from Raspbian) is Audacity, which you can download from [`www.audacityteam.org`](http://www.audacityteam.org).

Audacity is a useful tool for all sorts of purposes, such as producing blogs, creating multi-layered sound effects, grabbing cuts of audio for presentations, and so forth.

To install Audacity on your Raspberry Pi, make sure the board is connected to the Internet and type:

```
sudo apt-get install audacity
```

Click the Menu button (which is next to the raspberry on the Raspbian GUI) and then type the command `audacity` in the Run box. The program starts and displays a screen like the example shown in Figure 11-6. An audio file of Beethoven’s stirring “Ode to Joy” (a `.wav` digital audio file) is already loaded in and ready to edit.

![[FIGURE 11-6:](#14_9781119183938-ch11.xhtml#rc11-fig-0006) Audacity running on the Raspbian desktop of a Raspberry Pi 2 Model B](./media/images/9781119183938-fg1106.png)

Editing an audio file is very similar to using a word processor to edit a text document. You insert the cursor where you want to make a change, hold down the left mouse button and drag to select an area of the wave form. Click the Delete button to erase the selected section, and the waveform is shortened seamlessly. The copy, paste and undo functions all work very much the same as they do in the word processor.

Audacity includes lots of effects, and you can download and install more. Figure 11-7 shows a few of the included effects. Click Help on the menu bar for information on how and why to use them.

![[FIGURE 11-7:](#14_9781119183938-ch11.xhtml#rc11-fig-0007) The Effect menu in Audacity](./media/images/9781119183938-fg1107.png)

[Figure 11-6](#14_9781119183938-ch11.xhtml#c11-fig-0006) shows a stereo waveform with left and right channels, or two tracks. However, nothing limits you to only two tracks. Record yourself playing a guitar. Add in another track playing the same music on a banjo, on a trumpet, some drums, and so on. Sync it up, add a few effects, and you have a major musical production. Mix all the tracks down into left and right for stereo and you’ve got a hit on your hands.

Figure 11-8 shows four tracks in Audacity. The two original “Ode to Joy” tracks have been copied and pasted slightly offset into an additional two tracks. Playing the result gives an interesting sound—not good, kind of weird, but interesting.

![[FIGURE 11-8:](#14_9781119183938-ch11.xhtml#rc11-fig-0008) Additional tracks in Audacity](./media/images/9781119183938-fg1108.png)

#### Some Specifics of Encoding and Decoding

Audio and video files use standards called codecs. A _codec_ is a device or software for encoding and/or decoding a digital stream or signal. Reasons for doing this include compressing a file to save space, encrypting for copy protection and improving playback. The Raspberry Pi hardware knows how to decode the most common formats. You can also add other formats as needed.
