Chapter 12

# Input/Output

**WHEN WE DISTIL** computerised data processing down to its very essence, we require only two things of our computers—_input_ and _output_, or _I/O_. You put data and commands in, and you receive processed data out. It’s a simple enough concept, but more than 70 years of electronic computers and the allied development of a veritable galaxy of peripheral devices make it more complicated.

This chapter attempts to demystify this complexity via an overview of I/O and the computer architecture behind it. Of course, there’s special emphasis on the Raspberry Pi, with an eye to some practical uses.

We begin with a short history of interfaces and their related protocols. Next, we examine various I/O schemes involving UARTs, USB, SCSI, IDE/PATA, SATA, I<sup>2</sup>S, I<sup>2</sup>C, SPI, GPIO and others. Yes, that is a double handful of acronyms, but most of them provide rather elegant solutions to specific I/O needs that we define and explain in this chapter.

The chapter concludes with a Raspberry Pi-specific section on using general purpose input output (GPIO). The two rows of GPIO pins on all the Raspberry Pi models differentiate them from most computers. Using these programmable inputs and outputs allow this credit-card-sized board (even smaller in the case of the Raspberry Pi Zero) to control everything from a tiny blinking LED light to massive electric motors drawing thousands of watts of power.

So, let us meet those cybernetic brothers: input and output.

## Introducing Input/Output

Computing devices have been around for a lot longer than many people realise. The abacus—that simple adding and subtracting instrument that uses beads strung on wires—most likely originated in Babylon in the mists of history, several centuries BC. The famous Antikythera device discovered in an ancient shipwreck appears to be a mechanism for predicting the movement of stars and planets, dating from about the first century BC. Tools like these work differently from modern computers, but they both take input and produce output.

The advent of modern I/O took place much more recently, and began with a mouse.

Early computing focused on things the computer was good at, essentially arithmetic calculations and data processing. However, for computers to become the universal helpmates they are today, better methods of input and output were needed. Punched cards and magnetic tape were slow. The advent of terminals where the operator typed text on a keyboard and the computer returned words on a screen was an improvement but it was still cumbersome, even after the keyboard became attached to the computer.

Computers and people needed a better interface. In addition, computers needed to talk with other computers (network) and exchange various forms of data at great speeds _accurately_. Therefore, a proliferation of I/O hardware methods and communications protocols was developed. Those things are the basic subject matter of this chapter, but first we must consider the computer/human interface.

Two inventions changed the face (literally) of the computer: the graphical user interface (GUI) and the now ubiquitous mouse. Which came first? Somewhat surprisingly, it was the mouse, and it was a military secret!

#### The Mouse

A _mouse_ is a computer peripheral that detects two-dimensional motion on a flat surface and converts it into the movement of a cursor (an arrow or other graphic on a computer’s screen). Clicking the mouse’s button or buttons results in various commands transmitted to the computer.

Early mice used a small rubberised ball to sense motion. Most mice today employ use LED light sources and an array of photo sensors. Many now are also wireless, eliminating the cord coming out of the back like a real mouse’s tail (the source of the device’s name).

Douglas Engelbart and his team at the Stanford Research Institute developed and named the original mouse in the 1960s (see Figure 12-1). Engelbart did much more than just make today’s many varieties of mice possible, but he’s a hero to all of us who make our daily bread by moving a mouse around on our desk.

![[FIGURE 12-1:](#15_9781119183938-ch12.xhtml#rc12-fig-0001) Xerox Star 8010, commercial GUI](./media/images/9781119183938-fg1201.png)

If the mouse is such a great idea, why wasn’t it invented sooner? Well, like many great concepts, precursors to the mouse did exist. In 1941, Ralph Benjamin developed a trackball to control a fire-control radar plotting system for the Royal Navy. The fire-control system originally used a joystick device and analog computers in calculating the future position of aircraft for targeting. Benjamin decided a better input method was required and invented a trackball, which he called a “roller ball”. In the 1950s, the Royal Canadian Navy controlled digital computer systems with trackballs. Both of these uses fell under the cloak of military secrecy and didn’t spread to the larger computing world.

So, Doug Engelbart independently invented the mouse. Sadly, he never received a cent in royalties, but we all owe him our thanks for his immense contribution to computer I/O. With Engelbart’s invention, we now had a means of pointing, and computers needed something to make pointing useful. Enter the GUI.

#### The Graphical User Interface

A graphical user interface (GUI, pronounced “gooey”) lets us interact with computers and other devices by the use of text, icons and other visual indicators. The older text-only displays often required the typing of long, counter-intuitive commands as opposed to the faster and easier GUI solution of pointing and clicking.

Doug Engelbart made another contribution. This time, it was his turn to provide us with the precursor to something, in this case text-based hyperlinks/hypertext (_a la_ the Internet) that could be clicked on using a mouse (which, thanks to him, already existed) making the link do something, like take you to another screen or perform a command.

From there, Palo Alto Research Center (PARC, owned by Xerox) and Alan Kay, one of the key researchers at PARC, moved computers past text-based hyperlinks and into the world of GUIs. In 1973, the Xerox Alto computer was released. It was the first computer to use a GUI as its main interface, and it accepted input from both the keyboard and a pointing device. This GUI, called the PARC user interface, had elements that are familiar to us today—windows, menus, buttons and check boxes.

---

> [!NOTE]

The first GUI didn’t include icons. Icons came along later thanks to one of Alan Kay’s team, David Smith.

It took several years for GUIs to become available on the market. The first commercial release of a computer with a GUI was the Xerox Star 8010 in 1981 (see [Figure 12-1](#15_9781119183938-ch12.xhtml#c12-fig-0001)). In 1983, Apple got into the game and produced the first Apple with a GUI, the Lisa. Lisa was not an outright success, but it did introduce a menu bar and windows controls, which are things we take for granted in today’s GUIs.

Then, in 1984, Apple released the Macintosh computer, which was _truly_ the game changer for GUIs. Given the success of the Mac, several other computer manufacturers and software companies were looking at GUI. Atari and Commodore joined their ranks in 1985, and Microsoft pushed out Windows 1.0 later that same year. No one’s looked back since.

Today, most operating systems—Windows, Linux, Mac, Android, iOS, you name it—sport GUIs as their primary interface with humans. Advantages of GUIs include:

- They’re easy to use, especially for newcomers to computing. - What you see is what you get (WYSIWYG, pronounced “wizzywig”), meaning that what you see on the screen is exactly how the printed product will look. - They usually provide Help facilities. - They can be used without long strings of commands. You just point to a menu and click to see a list of possible commands.

  ---

[!NOTE]

>

Server installations worldwide still use commands typed at the command line, and those commands are exceptionally useful and worth learning.

- They offer simple ways of moving data between applications, such as drag and drop or copy and paste. - They allow photos and other graphics to be easily manipulated.

Of course, like anything, GUIs also have disadvantages:

- They require more RAM (working memory). - They take up more space on hard drives or other permanent storage, such as the Raspberry Pi’s microSD. - They require more overheads for software developers to create them.

GUIs dominate computer operating systems and have made it easier for humans to interact with computers. Yet computers talk not only to us but also to all sorts of devices, both locally and over networks. So let’s look at some very important types of I/O and the computer architecture supporting them.

## I/O Enablers

The concept of computer I/O devices, also called computer _peripherals_, consists of devices that accept data input, output processed data, or perform both in and out functions.

Here’s a simplification of how I/O devices work. They include _sensors_, which are often some sort of device that detects and responds to input from the physical environment. Sensors detect motion, temperature, changes in air or gas pressure and so on, and the sensors feed data or instructions to a computer for processing, storing or initiating a command. The computer may then (if required) present the results to a human or to a machine it controls. Basically, one or both of the following functions occur:

- **Input:** The device converts analog or digital data and instructions, sending an electrical signal in binary format (1s and 0s, digital format) to the computer. - **Output:** The computer sends digital signals back to the device, which converts those signals into whatever format the device understands.

Table 12-1 lists some examples of I/O devices.

<figure> <figcaption>

[Table 12-1](#15_9781119183938-ch12.xhtml#rc12-tbl-0001) I/O Devices

</figcaption>

**Input** **Output** **Input/Output** ------------------------------------------------------------------------ --------------------------------------------------------------------------------------------------------------------------- ---------------------------------------------------------------------------------------------------------------------------- A mouse inputs signals from its movement on a two-dimensional surface. Printers print pages sent from the computer. A network card makes possible continuous communication with other computers on the network as well as on the Internet. Keyboards report keys pressed. Displays show a GUI with windows, menus, buttons, the mouse’s moving cursor and so on. Disk drives store and retrieve data via a Serial AT Attachment (SATA) or other type of interface. Motion sensors report true or false that a motion has occurred. On the detection of motion in a secure area, the computer causes a siren to sound and/or alerts a designated human guard. USB peripherals send status and receive commands from the operating system assisted by the driver program for that device.

</figure>

The next sections examine some specific ways I/O happens.

### Universal Serial Bus

Universal Serial Bus (USB) is a method of both input and output. Where the Raspberry Pi is concerned, it is not by accident that the newer models boast four USB plugs (see Figure 12-2) because USB has become indispensable. You’ll find four ports a bare minimum for many projects.

![[FIGURE 12-2:](#15_9781119183938-ch12.xhtml#rc12-fig-0002) The four USB receptacles on the Raspberry Pi 2](./media/images/9781119183938-fg1202.png)

USB allows easy and convenient connection of all sorts of devices, including keyboards, mice and other pointing devices, portable hard drives and thumb drives, network adapters, microphones, CD and DVD drives and much, much more. Even smartphones and game consoles include USB plugs these days.

We begin with some history of USB and its evolution through the various versions (1.0, 1.1, 2.0, 3.0 and 3.1) and then we then offer some detail on the versatility of USB for the Raspberry Pi.

#### History of USB

Beginning in the early 1980s, the explosive popularisation of personal computing meant a vast proliferation of peripherals was developed for this lucrative market. This often created a rat’s nest of cables and power supplies behind computers and spilling off the desk and onto the floor.

USB came about to standardise and eliminate much of this clutter. USB replaced and/or consolidated many earlier types of interface. Parallel ports, serial ports and many separate power supplies landed in the dustbin of computer history, thanks to USB plugs, power and other standards.

USB, as an industry standard, was first released in the mid-1990s. The standard specifies the necessary cables, connectors, communications protocols and the power supply between computers and peripheral devices. All of the preceding specifications enable USB to be implemented by many manufacturers and work interchangeably.

Originally, a consortium of seven companies—Compaq, DEC, IBM, Intel, Microsoft, NEC and Nortel—pushed the development of USB. Today, the developers and maintainers of the USB standard (the current version is version 3.1) form the USB Implementers Forum, which is a non-profit organisation.

#### Versions of USB

There have been three releases of USB standards:

- **USB 1.x:** USB 1.0 was the first release in 1996. It provided specified data rates of 1.5 Mbit/s (megabits per second, low bandwidth, low speed) and 12 Mbit/s at full bandwidth (also referred to as “full speed”). USB 1.1 followed in 1998 and corrected problems that had become apparent in 1.0, especially in hubs.

  In addition to fixing problems, USB 1.1 became widely accepted and implemented by computer manufacturers, leading to “legacy-free” PCs. A _legacy-free PC_ is one in which the floppy drive controller, parallel printer port, RS-232 serial port, game ports and Industry Standard Architecture (ISA) expansion bus were all replaced by USB ports. This enabled the building of simpler PCs and contributed to driving prices down, a major impact of USB.
- **USB 2.0:** This version arrived in 2001. It features a higher data transfer rate of 480 Mbit/s, which is 40 times faster than version 1.1.
- **USB 3.0:** In 2008 the USB standard got another huge speed increase, this time up to 5 Gbit/s (gigabits per second—that’s fast). This version of the standard also had lower power consumption and increased power output, and it was backward compatible with USB 2.0. The first computers and other devices with actual 3.0 ports, called SuperSpeed ports, came out in 2010. If you see a USB port on your computer with a small SS over it and a blue plastic guide inside, it’s a USB 3.0 port. Of course, if it is labelled “USB 3.0”, that’s a pretty good indicator as well. December 2014 saw the approval of USB 3.1 standards with increased speed, this time a blistering 10 Gbit/s.

#### USB Architecture

USB design includes a host controller that allows for numerous USB ports with multiple devices attached in a tiered star topology. Star networks (see Figure 12-3) are one of the most common arrangements, in which a central computer or hub controls communication with the devices around it. It is a client-server set up. This configuration’s advantages emphasise reliability; if one client or connection drops out, the other connections are not affected.

![[FIGURE 12-3:](#15_9781119183938-ch12.xhtml#rc12-fig-0003) Star configuration](./media/images/9781119183938-fg1203.png)

Adding to the flexibility of the network topology is the fact that any physical USB device may have subdevices, which makes it possible for one device to have several functions. For example, a webcam with a built-in microphone has a video device function and an audio function. We call these _composite_ devices (that is, they’re composed of more than one function).

The USB standard also includes _device classes,_ which are software drivers for class codes and give the USB host the ability to connect easily to the various classes of devices supported. This gives the host the ability to recognise devices from different manufacturers so long as those devices provide the standard device codes.

Device classes include:

- **Audio:** Speaker, microphone, sound card, MIDI - **Communications:** Modem, network adapter, Wi-Fi, RS232 serial adapter - **Human interface:** Mouse, keyboard, joystick, trackball - **Image:** Webcam, scanner - **Printer:** Laser printer, inkjet, and CNC (Computer Numerical Control) using in automating machinery. - **Mass storage:** USB flash drive, memory card reader, digital audio player digital camera, external hard drive - **USB hub:** Controls connected USB devices that are connected to the hub - **Video:** Webcam, surveillance cameras, consumer and professional video cameras and so on

In addition, there are other classes such as those for personal healthcare devices, compliance testing devices, smartcard readers, fingerprint readers and test measurements.

On the Raspberry Pi boards are two large surface mount chips. The largest is the Broadcom SoC 2835 on the first models and 2836 with four-core central processing unit (CPU) on the Raspberry Pi 2 and the new Raspberry Pi 3. The second, somewhat smaller chip is a SMSC LAN9512 USB hub and Ethernet controller. This latter chip handles the USB and networking services.

### USB Powered Hubs

USB ports allow you to plug in and running a keyboard, a mouse and all sorts of other devices, including big hard drives. However, as we touched on in the introduction to this chapter, onboard USB also has current limits. In the case of the Model B, it should only be used for low-power devices.

---

> [!WARING]

When you exceed the power limits of the on-board USB, bad things happen, such as possible damage to components. Consider adding a powered USB hub for high current requirements.

If you’ve used the Model B, the lack of enough USB ports (the official name is “receptacle”) is probably aggravating. After you plug in a keyboard and a mouse, you are stuck—there’s no more room at the inn. In addition, if you use the wrong mouse or keyboard—that is, those with high current drain—it could cause the board’s power supply to shut down.

#### USB Power

The USB 1.x and 2.0 specifications approved by the USB Implementers Forum allow for 5 volts direct current (VDC) from USB hubs on one wire for powering USB-connected devices. The variance in voltage is limited to a range of 4.75 VDC to 5.25 VDC. In USB 3.0, the variance increases to 4.25 VDC to 5.25 VDC.

As we have mentioned, the Raspberry Pi Model B current is limited compared to later models. The newer “+” models have proper USB power handling. A hub before 2.0 allocates a maximum of five unit loads (500 milliamperes \[mA\]) to a connected device or 750mA under USB 3.0. Slightly complicating these current limits, two types of devices exist: low power and high power. A low power device can draw at most only one unit load. A high power device usually operates as a low power one but can request more current and get it if available at the time from the hub.

---

> [!NOTE]

The current sourcing abilities of almost all USB ports differ from what the specs mention. The specs state, for instance, that without negotiation, a USB 2.0 device is allocated only 100mA (with negotiation up to 500mA). Negotiation for additional power comes through the Power Delivery protocols interfaced through a bidirectional data channel to control the power supply.

The reality is most boards/power supplies ignore this spec and source whatever 5V VDC is available in the system. Devices such as high-speed external hard drives may require _more_ power than is available via the Raspberry Pi’s USB receptacles. In such cases, the device may have a Y-cable with two USB plugs. Connecting to two USB receptacles, in the USB specs at least, raises the maximum current load to 1 amp for USB 2.0 and earlier versions or 1.5 amp for USB 3.0.

Of course, the hub must be able to supply this amount of current. Using the USB controller on a Raspberry Pi, you _do not_ have unlimited load. The solution involves adding an external hub with its own power supply and greater current-supplying capacity than the Raspberry Pi by itself.

#### Rapsberry Pi USB Power Solution

The Model B+ and the Raspberry Pi 2 come with four USB ports! Now, don’t do a happy dance across the room just yet. Although having four USB ports instead of two does add flexibility and offers more current, there are still limitations. A good powered USB hub, like the one shown in Figure 12-4, is a way to work around those limitations.

![[FIGURE 12-4:](#15_9781119183938-ch12.xhtml#rc12-fig-0004) A USB powered hub](./media/images/9781119183938-fg1204.png)

Such hubs usually have seven or more ports and receive power through a wall plug. Thus, you get power to run hard drives and other juice-hungry devices without overtaxing your Raspberry Pi board’s limited resources.

---

> [!NOTE]

Be sure to choose a powered USB hub that supports the Raspberry Pi. Do an Internet search for “powered USB hub” for lists of manufacturers and model numbers.

### Ethernet

_Ethernet_ in general consists of several computer-networking technologies. First introduced in 1980 and standardised in 1983 as IEEE 802.3, its development has been continuous since that time. Speeds have increased from 2.94 Mbit/s to 100 Gbit/s (gigabytes per second). By 2017, a speed of 400 Gbit/s is planned.

Networks enabled by Ethernet stream data in short pieces called “frames”. A frame includes source addresses (where it comes from) and destination addresses (where it’s going). Error-checking data causes the frame to be discarded if it arrives corrupted. In the case of a corrupted frame, a resend request can be triggered so that no data is lost.

#### Network Configurations

Similar to the way USB hubs control devices in a star configuration, networks (which were first to use the star topology) have clients connected to a hub. Hubs may be “bridged” (a connection made to another star configuration) to add more networks, both local and remote. The result is a vast collection of interconnected networks, which we call the Internet.

#### Raspberry Pi Networking

There are two ways to achieve network connectivity with the Raspberry Pi. The first is a wired connection that uses the Ethernet socket on the Raspberry Pi (excluding the Raspberry Pi Zero, which does not have an Ethernet socket). Figure 12-5 shows the socket, which accepts a standard network cable plug. The Ethernet port on the Raspberry Pi supports connections of 100 megabits per second (Mbit/s).

![[FIGURE 12-5:](#15_9781119183938-ch12.xhtml#rc12-fig-0005) Ethernet port on the Raspberry Pi 2 Model B](./media/images/9781119183938-fg1205.png)

The second way of connecting to the network involves the USB ports. You can use a wireless USB dongle (a dongle is a plug-in device) or a USB-to-Ethernet adapter. The USB wireless device allows easy connection to Wi-Fi networks in the area, and the USB-to-Ethernet effects a physical connection by providing a socket for a standard Ethernet cable.

A wireless dongle is handy if you want your Raspberry Pi to be portable. With an external battery power supply and wireless access, you can carry it anywhere! That is, you can carry it anywhere with wireless access, which is true for more and more places these days.

All sorts of tasks require a connection to both your local network and the Internet. Upgrading the operating system and the Raspberry Pi’s firmware require Internet access, unless you decide to swap out the SD card as an alternative. Downloading and installing programs, web surfing, using the Raspberry Pi as a media centre to deliver movies to your flat-screen TV and many other tasks make networking a necessity.

### Universal Asynchronous Receiver/Transmitters

Universal asynchronous receiver/transmitters (UARTs) use a set of registers to accept and output data. Older UARTs could translate data between parallel and serial formats, but modern UARTs do not have this capacity. The personal computers of yesteryear used to have serial ports as a standard feature. The now ancient (in computer years) RS-232 serial format (which ran these ports) is implemented via a UART. Serial ports such as these can still be found on various industrial instruments.

The UART works by breaking down bytes of data into their individual bits and sending those serially (one after the other). At the destination, the receiving UART reassembles the bytes. The advantage of serial transmission over parallel transmission lies in its cost; just a single wire is required. The Broadcom SoC on the Raspberry Pi has two UARTs.

A common use for UARTs is in microcontrollers, and the Raspberry Pi excels as a control device. The Raspberry Pi’s onboard UART comes inside the Broadcom SoC containing the CPU (or CPUs), graphics processing units (GPUs) and all those other goodies. It’s accessed and is programmable using the GPIO’s pin 9 (transmit) and pin 10 (receive).

Read more on the GPIO in the last section of this chapter.

### Small Computer Systems Interface

Small Computer Systems Interface (SCSI) provides standards for moving data to and from computers and peripherals, especially hard drives (although it’s also good for scanners and other devices). SCSI has been around since the early 1980s and was once the gold standard of hard drive interfacing.

SCSI transfers data in parallel. To use it with a Raspberry Pi, such as by adding a SCSI drive, is possible via USB but a serial-to-parallel adapter cable is required. Such adapter cables cost about £15 and are readily available from major online computer parts retailers.

---

> [!NOTE]

SCSI is very much on the way out, and it’s unlikely that you’ll find a use for it.

### Parallel ATA

The Parallel Advanced Technology Attachment (PATA) standard is also known by several names:

- Integrated Drive Electronics (IDE) - Extended Integrated Drive Electronics (EIDE) - Ultra Advanced Technology Attachment (Ultra ATA)

No matter what you call it, PATA is an interface standard for connecting and passing data to and from hard disks, floppy disk drives and optical disc drives in computers. It has gone through many incremental developments and, like SCSI, it has been superseded by other standards. (See the next section on SATA.)

PATA cables have one significant limitation: they can be no longer than 18 inches. Because of this restriction, their primary use was as interfaces inside computer cases. Because PATA cables were the least-expensive solution for passing data to and from hard drives especially during the late 1980s to early 1990s, they were widely used.

If you have old PATA drives that you’d like to hang off your Raspberry Pi board, you can use a conversion cable to make the connection. The cables aren’t expensive—less than £15 for a set of conversion cables that will handle IDE/PATA and/or SATA.

---

> [!NOTE]

Remember that any time you add something to the Raspberry Pi that draws the type of current a hard drive does, you should use a powered USB hub as discussed earlier.

### Serial Advanced Technology Attachment

Serial Advanced Technology Attachment (SATA) devices communicate over a serial cable using two pairs of conductors. Its primary use connects computers and other devices to hard disk and optical drives. Two important advantages of SATA over SCSI and PATA are that it is speedier and uses less wiring, especially in the case of the older IDE interfaces.

In the late 1980s and 1990s, drives were installed in PCs with flat, grey, multi-conductor ribbon cables. The cables usually sported a red stripe on one side so people would know which way they plugged into the ribbon connector (to avoid possible damage to hardware). Because the data interchange was parallel, such cables required many conductors. SATA has replaced PATA in consumer and most business devices. However, some industrial and other uses of embedded flash memory still use the older PATA interfaces.

The current version of SATA, Revision 3.2, features communication speeds of 16 Gbit/s and actual data transfer of 1969 MB/s. As mentioned earlier, several inexpensive adapters exist for converting SATA drives to USB, which makes it possible to connect SATA devices to the Raspberry Pi via its USB receptacles. Here’s another reminder that you should use a powered hub to make sure the drive gets adequate power and to reduce the chance of causing damage to the Raspberry Pi due to current overload.

### RS-232 Serial

RS-232—a long-time standard for the serial transmission of data—was _the_ standard and common on many personal computers in the 1980s and 1990s. Before PCs, RS-232 provided communications with terminals like the ones used to control mainframes and minicomputers.

All sorts of other peripherals once connected via RS-232 serial ports—printers, mice and other pointing devices, modems and more. However, RS-232 had some disadvantages:

- Variations in voltage due to long cables and mismatched transceivers - Speed limitations - Large, bulky connectors

USB came along in large part to cure these three disadvantages. RS-232 is still around, however, as connectors with industrial machines, as control ports in large networking devices and on various scientific instruments.

---

> [!NOTE]

TTL (Transistor-Transistor Logic) level serial is what almost everyone uses these days. It’s sometimes mistakenly referred to as RS2232.

### High Definition Media Interface

High Definition Multimedia Interface (HDMI) allows the transfer of video and audio from an HDMI-compliant display controller (think Raspberry Pi here) to compatible computer monitors, projectors, digital TVs or digital audio devices.

HDMI’s high quality provides a marked advantage over composite video (such as what comes out of the composite video connector on the Raspberry Pi board). HDMI provides higher resolution instead of composite video’s noisy and sometimes distorted picture.

Most TVs sold today include HDMI input ports, as do higher-end video monitors. If you don’t have a TV that has an HDMI port, no problem. Here are two solutions for getting HDMI into non-HDMI devices:

- **Digital Video Interface (DVI):** You’ll find computer monitors with DVI inputs more common than ones accepting HDMI. Just search online retailers for “hdmi to dvi” and you’ll find several solutions (cables and adapter plugs) in the £4 to £7 range. - **Video Graphics Array** (**VGA):** Most common of all are VGA monitors. A search for “hdmi female to vga male” will get you the right adapter in the £4 to £7 range. This is an active conversion; there is actually some circuitry inside the adapter cable that converts digital signals to analog. In the case of HDMI to DVI, it’s just a remapping of digital signals; HDMI to VGA is more complicated and not as robust.

It is important to know that HDMI-to-HDMI connections include _both_ video and audio. For connections converting HDMI to DVI or VGA, you will find only video goes through the connection. Your options for audio include a separate audio cable from the audio out port of the Raspberry Pi. Alternatively, some adapters have audio ports. You still need to run an audio cable from the converter’s connector to the audio input on the monitor or to separate speakers. However, connecting the cable to the HDMI output of the Raspberry Pi gives better quality. This is the easy way to do it.

### I<sup>2</sup>S

Inter-IC Sound (I<sup>2</sup>S), a communications protocol for carrying digital audio signals, is a type of serial bus interface standard that connects digital audio devices together. (You can read more about I<sup>2</sup>S in [Chapter 11](#14_9781119183938-ch11.xhtml).) This protocol came from the Dutch technology giant Philips in 1986 as an internal feature of its CD players. The last revision happened in 1996 but this does not hamper its utility.

The following are some choices for good audio from the Raspberry Pi. Which is the correct answer?

1. Use audio output from the 3.5mm audio jack, which comes from Pulse Wave Modulation (PWM) in converting from digital to analog. It’s limited to about 11 bits, a rate causing some to turn up their noses (or ears) at it. 2. HDMI, which is supposedly “high definition”. 3. USB. 4. Hook a good digital audio converter (DAC) with I<sup>2</sup>S directly to the Raspberry Pi.

The answer, of course is “D”.

However, where do you hook it? There’s no discrete connector plug for I<sup>2</sup>S on the Raspberry Pi board. Instead, you use the GPIO pins, and you can do that the hard way or the easy way.

The hard way is by using jumper cables to directly access the needed GPIO pins. Four give you access to the I<sup>2</sup>S interface on the Broadcom SoC chip that has the CPU, GPU and so on.

The easy way is by purchasing one of the DAC units mentioned at the end of [Chapter 11](#14_9781119183938-ch11.xhtml). They simply plug onto the GPIO pins and piggyback the Raspberry Pi board, providing a short, noise-free connection with that golden quality sound.

Some configuration is required to turn on and set up the I<sup>2</sup>S interface. One method is to use Python on Raspbian or a similar Linux-based operating system on the Raspberry Pi. You’ll find a good deal of help on the web for achieving great sound from your Raspberry Pi on the Internet. You can search “raspberry pi sound” for tips and devices.

### I<sup>2</sup>C

The I<sup>2</sup>C (Inter-Integrated Circuit) communications protocol also comes from Philips. I<sup>2</sup>C is a communications bus, providing communications between chips on a printed circuit board. One of its prime uses on the Raspberry Pi board and elsewhere lies in connecting sensors.

I<sup>2</sup>C is not initialised when the Raspberry Pi first comes out of the box. You have to tell the Raspberry Pi to use it. You accomplish this under the Raspbian OS (and other operating systems) with the `raspi-config`</code> command in the terminal. On the command line, type

```
sudo raspi-config
```

Use the down arrow key to select 9 Advanced Options and press the Enter key. On the next screen, select A7 I2C to toggle the automatic loading of I2C on or off. (See Figure 12-6.) A reboot is required each time for the new state to take effect.

![[FIGURE 12-6:](#15_9781119183938-ch12.xhtml#rc12-fig-0006) Enabling I<sup>2</sup>C on Raspberry Pi using `raspi-config`](./media/images/9781119183938-fg1206.png)

As with most interfaces related to the GPIO pins, many of which enable connection to services on the Broadcom SoC, some programming is required. The steps in shell scripts or Python (one of the favoured methods of GPIO-programmed control) are beyond the scope of this book, but there are many examples on the web. You can search for “raspberry pi gpio python scripts”.

### Raspberry Pi Display, Camera Interface and JTAG

Before we get to GPIO, we have two more interfaces to mention. These two interfaces connect with ribbon cable connectors:

- **Camera Serial Interface (CSI)** (the MIPI CSI-2 standard): This interface allows the connection of a camera. Cameras for the Raspberry Pi are available. It is sometimes a bit irksome to connect the ribbon cable just right, but once things are hooked up properly you can program the Raspberry Pi to do all sorts of neat stuff with digital photography and video. Camera boards/modules cost about £25, so experimenting is possible at a reasonable cost. - **Display Serial Interface (DSI):** This interface enables you to connect small displays to the Raspberry Pi board. This makes the Raspberry Pi, along with a battery power source, truly portable. A simple LED device costs about £9 whereas the official Raspberry Pi 7-inch touchscreen LCD monitor costs £65.

---

> [!NOTE]

The JTAG Header for debugging was on the older Raspberry Pi boards but isn’t on the Raspberry Pi 2. JTAG provides facilities for debugging using techniques such as stepping through code and using break points (stopping at various places in the code). JTAG on newer boards is available via GPIO pins.

## Raspberry Pi GPIO

The general purpose input output (GPIO) performs magic in tying the Raspberry Pi to the real world. Through these pins, the Raspberry Pi is programmed to control microcontrollers and real-world devices—such as doorbells, light bulbs, model aircraft controls, lawn mowers, robots, thermostats, electric coffeepots, motors of all sorts—that normally cannot connect to a computer or follow its orders.

We start by exploring the truly exciting wonders of GPIO control with the original Model B (as opposed to the current Raspberry Pi 3). The Model B (see Figure 12-7) has fewer GPIO pins than the two next releases—the Model B+ and Raspberry Pi 2. The extra pins on those versions work the same but give added capacity—but let’s keep it simple for the moment. The pin assignments for the first 26 pins remain the same on all models of the Raspberry Pi.

![[FIGURE 12-7:](#15_9781119183938-ch12.xhtml#rc12-fig-0007) GPIO pins on Raspberry Pi 2](./media/images/9781119183938-fg1207.png)

### GPIO Overview and the Broadcom SoC

The key to making the Raspberry Pi possible at such an incredibly low price is the Broadcom system-on-a-chip (SoC). As previously mentioned, in this one chip live CPU(s), GPUs and various interfaces, including UART, I<sup>2</sup>C, SPI (Serial Peripheral Interface) and so forth. The GPIO pins allow us to program these interfaces and also do much more.

The GPIO pins (P1 on the Raspberry Pi boards—either 26 on earlier models or 40 on the newer ones) allow configuration (that is, they are _programmable_) in several ways, such as:

- General-purpose input - General-purpose output - Up to six alternative settings, depending on the pin

The following items apply to most pins, but some are used as positive voltage sources or grounds:

- **Power-on states:** GPIOs (depending on the operating system and firmware in use) reset to general-purpose inputs when the board is rebooted. - **Interrupts:** Each pin is programmable to generate an interrupt to the Broadcom’s CPUs/GPUs. These interrupts can be configured as: - Level-sensitive - Rising/falling edge - Asynchronous rising/falling edge. - **Alternative functions:** As mentioned earlier, almost all of the GPIO pins have alternative functions in addition to simple switching operations. These involve direct connections (through the pins) to Broadcom IoC. The peripherals in the SoC, such as the UART and I<sup>2</sup>C buses, can be programmable to at least three sets of pins.

---

> [!NOTE]

For more information on connecting to these low-level peripherals, visit [`http://elinux.org/RPi_Low-level_peripherals`](http://elinux.org/RPi_Low-level_peripherals).

#### GPIO Header 1

GPIO 1 refers to the P1 connector on Raspberry Pi boards—either the 26 pins on Model A and Model Bs or the 40 pins on the B+, Raspberry Pi 2 Model B and the new Raspberry Pi Zero.

#### GPIO Header 5

GPIO 5 provides additional GPIO connections on the Model A and Model B via the P5 header. This header does not have pins, so any connection to it has to be soldered to the board. From the Model B+ on, additional pins added to the P1 header replace the P5 header.

### Meeting the GPIO

The GPIO performs magic in tying the Raspberry Pi to the real world. Through these pins, you can program the Raspberry Pi to control all sorts of real-world devices. First, we’ll examine these pins and understand just how simple and powerful they are. Then we’ll look at programming the Raspberry Pi to understand inputs, outputs and control devices.

#### Pin Layout

Figure 12-8 shows the GPIO pins on the Model B.

![[FIGURE 12-8:](#15_9781119183938-ch12.xhtml#rc12-fig-0008) Close-up of the Raspberry Pi Model B’s 26 GPIO pins](./media/images/9781119183938-fg1208.png)

There are 26 pins—two rows of 13 each. The bottom row pins (left to right) consist of odd numbers: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23 and 25. The top row pins (left to right) are even numbered: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24 and 26.

The pins, when set as outputs, act like switches and provide power, enabling the Raspberry Pi to interact with other devices and—in some cases—supply the electricity those devices need to run. Later in this chapter is an example of using the Raspberry Pi to flash some lights.

The IO in GPIO stands for input/output. When you have a device connected to the Raspberry Pi and flip an external switch or, more likely, some electrical or mechanical gizmo opens or closes, that’s _input_. It’s a changed condition causing a program running on the Raspberry Pi to respond with some sort of action.

Here’s an example of both input and output. You build a home security project using a Raspberry Pi. Someone opens an outside door. A wireless magnetic switch closes. The Raspberry Pi picks up the signal and closes a circuit, causing a chime to go off during the day or a siren at night. The door switch changes state from closed to open when it detects the door is ajar. A program on the Raspberry Pi outputs a switch closing, which causes the chime or siren to sound. Both tasks are accomplished through connections to GPIO pins—two different circuits were completed.

---

> [!NOTE]

Thanks to the Raspberry Pi’s ability to communicate in various ways—such as by wireless, Bluetooth or the Internet—inputs and outputs do not even have to be local. Devices and programs can be controlled from anywhere in the world!

Circuits closing and opening describe electronic control. See the “[Circuits](#15_9781119183938-ch12.xhtml#c12-fea-0001)” sidebar for additional explanation of circuits.
