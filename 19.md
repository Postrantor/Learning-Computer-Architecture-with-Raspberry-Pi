# Circuits

Electricity works in circles. (A closed loop is called a _circuit._) A very simple circuit, as shown in Figure 12-11, consists of a battery (voltage source) and a resistor (or load). The load performs work by resisting the voltage and consuming current as the battery overcomes the resistance to complete its circuit.

Putting a switch (a device that breaks the circuit when in the ‘off’ position and completes it when in the ‘on’ position) anywhere in the circuit gives us a way of controlling it.

If there is no load component (like a resistor), a wire from the positive to negative terminals of the battery creates a _short circuit_ and quickly depletes all the energy stored in the battery.

To use the GPIO pins, we need to make complete circuits and avoid short circuits or otherwise overloading the Raspberry Pi’s current-providing capacity. Don’t worry, you’ll be provided with safe guidelines for doing this later in this chapter.

Of the 26 GPIO pins on the Model B, 17 are programmable switches — specifically 3, 5, 7, 8, 10, 11, 12, 13, 15, 16, 18, 19, 21, 22, 23, 24 and 26.

Ground pins (places to complete a circuit) are 6, 9, 14, 20 and 25.

Pins 2 and 4 supply 5 volts (like the positive terminal on a battery). Pins 1 and 17 give 3.3 volts. Both require circuits that eventually come back to one of the ground pins noted earlier.

#### GPIO Operation

A GPIO pin, such as the 17 out of 26 pins on the Raspberry Pi B’s board that are programmable switches, works in _binary_ mode. Binary is just a fancy way of saying “on” or “off”. That’s how digital computers compute—they have bunches of circuits tied together, and those circuits are either on or off. In computer talk, 0 represents _off_ and the number 1 represents _on_. Programmers call the _state_ of the circuit—whether it’s on or off—_high_ (on) and _low_ (off).

---

> [!NOTE]

The high/low terminology is not strictly true in hardware interfacing with terms “active low” and “active high”. For instance, in SPI a chip select pin (CS) is “active low”, meaning that the chip will only respond (i.e. be “on”), when CS is set low (0V).

So how would you expect the Raspberry Pi to communicate with real-world devices? The 17 GPIO pins work with the Raspberry Pi’s internal voltage, 3.3VDC. When the logic state is high, the pin shows 3.3VDC. When the logic switches to low, the voltage is 0. By using this scheme, the Raspberry Pi can send commands out and/or receive incoming information.

Here’s how simple it truly is. One of the most basic circuits we can build is a light and a battery or other power source. We can do this easily with the GPIO pins.

Figure 12-9 depicts a simple binary on/off circuit. To make it, we choose an output pin and hook one side of an LED light to it using a jumper cable. (LEDs are low current and fun to use as indicator lights, etc.) The other side of the light connects to a 220-ohm resistor (more about this in just a moment) and the other side of the resistor connects to a ground pin.

![[FIGURE 12-9:](#15_9781119183938-ch12.xhtml#rc12-fig-0009) A GPIO simple LED circuit](./media/images/9781119183938-fg1209.png)

When the output pin is high (has voltage), the LED lights; the LED goes out when the pin has 0 voltage. Later we look at writing programs in Python, which let the Raspberry Pi control the GPIO pins.

---

> [!NOTE]

The resistor we used in the circuit in Figure 12-12 is a _current limiting_ component, which is a safeguard to prevent damaging both the Raspberry Pi and the LED.

Of course, you normally don’t use all 17 pins. The accepted rule of thumb is to limit each pin to a maximum of about 16mA and not exceed a total of 50mA. No _exact_ power specifications list exists for the Raspberry Pi. Such a list is impossible to create because there are too many variables, such as how the board gets its power and how it connects to a computer (using a USB port or by plugging into a converter connected to a wall socket). However, many smart Raspberry Pi experimenters have done measurements, and the figures we use in this chapter form a consensus of what’s safe and what’s not.

#### Managing Power

The issue with managing power on the Raspberry Pi stems from its main strength—its small size. On a board the size of a credit card, there is just no room for a massive power-handling circuit.

That makes it sound like there’s not much power available, right? Don’t worry; there’s plenty of power available. If you are careful, you can run mighty machines with the Raspberry Pi. You just can’t do it directly! Using GPIO requires using control circuits, which utilise relays, stepping switches and other types of external controllers, power transistors, microcontroller boards and other good stuff that lets the Raspberry Pi boss high-current devices.

There are two ways to make sure you are using damage-free current levels for the Raspberry Pi. You can _calculate_ it or _measure_ it. First, let’s look at calculation. It’s all about power, which we can measure using the following formula:

> _I = V / R_

where I expresses current (in amps), V is voltage (in volts) and R is resistance in ohms. So if you know the voltage (3.3 VDC) and the resistance, you can plug those numbers into the formula to determine the current. Multiply the answer by 1,000 and you’ll have milliamps.

Here’s an example: say we have a 220-ohm resistor. Divide 3.3 (the voltage) by 220, which results in 0.015. Multiply .015 by 1,000 and you get 15, or 15mA. That’s a safe current for one pin (so long as you do not exceed 50mA overall).

---

> [!NOTE]

About the only device you can power safely directly from the GPIO pins is an LED light. However, be sure to put a 220-ohm resistor in series with the LED to limit the current to a safe level.

The formula we just used is called _Ohm’s Law_ (see Figure 12-10). It’s a great tool for calculating safe limits for all your projects. Of course, with the Raspberry Pi, you’ll be working in milliwatts and milliamps (thousandths of watts or amps) and mostly 3.3 VDC.

![[FIGURE 12-10:](#15_9781119183938-ch12.xhtml#rc12-fig-0010) Ohm’s Law, where V = voltage in volts, I = current in amps and R = resistance in ohms](./media/images/9781119183938-fg1210.png)

The second way of testing for current level requires a test instrument—a _multimeter_—that measures voltage, current and resistance. You can find inexpensive digital readout multimeters online at Sparkfun ([`www.sparkfun.com`](http://www.sparkfun.com)), Adafruit ([`www.adafruit.com`](http://www.adafruit.com)) and other online retailers for £4 to £15. [Figure 12-11](#15_9781119183938-ch12.xhtml#c12-fig-0011) shows a multimeter.

![[FIGURE 12-11:](#15_9781119183938-ch12.xhtml#rc12-fig-0011) Multimeter](./media/images/9781119183938-fg1211.png)

You use a multimeter _before_ you connect the circuit. Two techniques work here:

- Measure the resistance of the circuit by connecting the multimeter (switched to ohms) across the positive and negative leads of the _unpowered_ circuit. If it reads 220 ohms or more, the circuit is a safe one.

  ---

> [!TIP]

An infinite reading means your circuit is open and will not work. Check your connections.

- Use a power supply set to 3.3 VDC. With the multimeter set to measure current (amps), put it _in series_ (make it part of the circuit) and check the current. If your reading’s greater than 16mA, add a resistor that limits the current to 16mA or less before connecting the circuit to the Raspberry Pi. [Figure 12-12](#15_9781119183938-ch12.xhtml#c12-fig-0012) shows an example of connecting a battery, resistor and amp meter (such as a multimeter switched to read current). When it’s in series with the circuit, the multimeter reads the amount of current the resistor consumes. In [Figure 12-12](#15_9781119183938-ch12.xhtml#c12-fig-0012), R1 the resistor (right) is represented by the standard symbol for a resistor. The battery is on the left with a plus (+) showing its positive side, and the A in a circle denotes an amp meter for measuring current.

![[FIGURE 12-12:](#15_9781119183938-ch12.xhtml#rc12-fig-0012) Measuring current with a multimeter](./media/images/9781119183938-fg1212.png)

---

> [!TIP]

Another great reason for owning a multimeter is for measuring the value of resistors. Resistors have bands of colour indicating how many ohms they are. If you’ve lost the package a resistor came in and don’t know the colour code, a multimeter comes in handy for finding that out. It’s beneficial to learn the colour code, as you won’t always have a multimeter with you.

All of the information provided in this section applies to the two 3.3V pins and the 17 switching pins. The two 5 VDC pins pull current through the Raspberry Pi’s 5 VDC “rail”(where all the board’s circuits get their power) and thus from the power source (USB port on a computer, external battery, a converter in a wall socket and so on). Because the current capacities vary widely, keep those current levels low. However, if you must have more power than the 3.3 VDC pins safely supply, the 5-volt pins might be useful.

---

CAUTION

Someone’s likely to point out that you _could_ disconnect the USB cable and run 5 VDC _into_ one of the 5-volt GPIO pins. This setup powers the Raspberry Pi and gives you more current for GPIO operations. The problem is that this bypasses the built-in fuse protection of the Raspberry Pi, which _is not_ a good thing and can result in current greater than a safe level, which can cause damage to the Raspberry Pi’s components. We recommend against it.

On the other hand, the GPIO truly gives the Raspberry Pi (and you) fantastic capacity for controlling real-world devices. It’s worth learning how to do this safely.

#### GPIO on the Model B+ and Raspberry Pi 2

If you have the new Model B+ or the Raspberry Pi 2 Model B, there are now 40 GPIO pins. For example, you will have 26 programmable pins overall instead of 17 (9 programmable pins have been added), two more grounds and a couple of pins (27 and 28) that are used as indexes by specialised plug-in boards. Figure 12-13 shows the GPIO pins on the Model B+.

![[FIGURE 12-13:](#15_9781119183938-ch12.xhtml#rc12-fig-0013) Close-up of GPIO pins on the Raspberry Pi 2 Model B](./media/images/9781119183938-fg1213.png)

### Programming GPIO

The Python scripting language is the recommended and easiest method of programming GPIO. It’s relatively easy to learn and comes standard in operating systems like Raspbian. To find out which version of Python you have, just go to the command line and type _python;_ the version is returned, as shown here:

```
python
Python 2.7.9 (default, Mar 8 2015, 00:52:26)
[GCC 4.9.2] on linux2
```

When you update Raspbian (something you should do regularly), any newer version of Python downloads and installs along with the latest updates of everything else in Raspbian. To update and upgrade Raspbian, type the following from the command line (use the terminal if you run a GUI):

```
sudo apt-get update && sudo apt-get upgrade
```

---

> [!TIP]

You should update Raspbian regularly for reasons of security and utility—that is, to keep your system secure while taking advantage of ongoing improvements in the hundreds of software packages on your Raspberry Pi.

Also, if this is your first time using GPIO, you’ll definitely want to install the Python GPIO library by using the following command:

```
sudo apt-get install rpi.gpio
```

---

> [!NOTE]

Python has many libraries of features and commands; you install only the ones needed for the tasks at hand.

Using Python, we write scripts to control the GPIO pins. The first step in writing one of these is to import the GPIO library, giving the script access functions concerning GPIO into your favourite editor, such as _nano_. Type the following command into the editor window:

```
import RPi.GPIO as GPIO
```

The next line specifies the layout of the GPIO pins (yes, you can change it). There are two choices: either match the layout on the board or use a numbering scheme matching the pins on the Broadcom SoC, as in:

```
GPIO.setmode(GPIO.BOARD)
```

Now we can start programming pins. Add the following lines to set pin 12 as an output:

```
GPIO.setmode(GPIO.BOARD)
GPIO.setup(12,GPIO.OUT)
```

or as an input:

```
GPIO.setup(12,GPIO.IN)
```

That’s it. Three lines in a Python script and you’ve set up the GPIO to actually do something. For a good starting tutorial on programming GPIO pins, including alternative modes, see “Raspberry Pi GPIO Pins and Python” at [`http://makezine.com/projects/tutorial-raspberry-pi-gpio-pins-and-python/`](http://makezine.com/projects/tutorial-raspberry-pi-gpio-pins-and-python/).

Using Raspbian Jessie (the latest release) on a Raspberry Pi 2 you can easily check GPIO pin settings. In the terminal, type:

```
gpio readall
```

and a table like the one shown in Figure 12-14 is generated.

![[FIGURE 12-14:](#15_9781119183938-ch12.xhtml#rc12-fig-0014) Table of GPIO pin assignments on Raspberry Pi 2](./media/images/9781119183938-fg1214.png)

#### Building a Simple Circuit

Are you ready to actually make something happen? How about turning on an LED and making it blink? We mentioned lighting an LED earlier but here we’re providing more detail so you can do it yourself. You need the following components to follow along with this example:

- A small LED (your choice of colour) - A 200-ohm resistor - A breadboard or alligator clips for making connections - Some small-gauge wire or jumper wires

---

> [!NOTE]

You could use a lower value resistor, but 200 ohms allows the LED to light brightly and the circuit draws less current. Less is always better when using GPIO pins, so use the minimum that you can to make your project successful.

Use the following steps to build a simple circuit:

1. Use a jumper wire to connect GPIO pin 7 (the positive side of the circuit) to one end of the resistor. 2. Look at your LED. LEDs usually have one wire leg longer than the other, or one leg might have a bend in it. This is the positive side. Connect it to the other end of the resistor. 3. Hook the negative side of the LED to GPIO pin 6, which is ground in the GPIO layout we’re using.

Your circuit is complete! It might look something like the one in Figure 12-15.

![[FIGURE 12-15:](#15_9781119183938-ch12.xhtml#rc12-fig-0015) Simple breadboard circuit for flashing an LED; the white overlay shows the circuit](./media/images/9781119183938-fg1215.png)

#### Example of Using Output

Now it’s time to write the simple Python script that controls the LED’s blinks. You use a text editor such as nano to write your Python script. Our script (with comments) is shown here.

```
## Blinking LED ###################################
import RPi.GPIO as GPIO   ## Import GPIO library
import time               ## Need this for blink delay
GPIO.setmode(GPIO.BOARD)  ## Use board pin numbering
GPIO.setwarnings(False)   ## Disable "Channel already
                          ## in use" warning
` 

led = 7                   ## Variable for pin number
GPIO.setup(led, GPIO.OUT) ## Set pin to output
` 

## Blink the LED 60 times, once per second for 2 minutes
` 

print "Blinking"          ## Blinking in progress
for x in range(0, 59):    ## repeats 60 times
     GPIO.output(led, 1)  ## Turn LED on
     time.sleep(1)        ## Keep it on for 1 second
     GPIO.output(led, 0)  ## Turn LED off
     time.sleep(1)        ## Wait 1 second
` 

GPIO.cleanup()              ## End program gracefully
```

---

> [!TIP]

If this script doesn’t work for you, check your circuit and also check for typos in the script. Typos are the most likely culprit. As with any code, things have to be exactly right for proper operation to occur.
